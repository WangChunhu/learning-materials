library(lubridate)
#提取日期时间
year(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
month(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
day(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
hour(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
minute(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
second(c("2016-07-22 10:11:22","2011-08-10 14:20:01"))
order(c("2016-07-22 10:11:22","2011-08-10 14:20:01","2001-08-10 14:20:01"))#只给顺序
hu <- data.frame(ordered(c("2016-07-22 10:11:22","2011-08-10 14:20:01","2001-08-10 14:20:01"))) 

#不同排列顺序
ymd("20160614")   #函数为处理前排序
mdy("06142016")
dmy("14062016")

# 时间数据运算
dminutes(2)   #120s
minutes(2)    #两个整分钟
leap_year(2019)   #是否为闰年
dyears(1)   #365d 
years(2)   #两个整年
ymd(20120101) + dyears(1)  #加365d
ymd(20120101) + years(1)   #加1年，即相同日期
ymd("2011-08-10") + dyears(2) + months(2) + ddays(2) + dhours(2) + dminutes(2) + dseconds(2)  #时间运算前必须加函数（month没有d）

# 时间区间
arrive <- "2011-08-10 13:50:00"
leave <- "2011-08-10 14:00:05"
int <- interval(start = arrive,end = leave)  #UTC是时区
arrive1 <- "2011-08-10 13:50:00"
leave1 <- "2011-08-10 14:00:09"
int1 <- interval(start = arrive1,end = leave1)
int %within% int1   #判断一个时间区间是否在另一个时间区间里面
as.period(int1)   #查看或计算一个时间区间的长度
int1/dminutes()   #查看或计算一个时间区间的长度(具体看写什么函数)



